import "operations.eol";

pre {
	var lifelines = UML!Lifeline.all;
	var dynamicViewName = "dynamicView";
	var staticViewComponentsName = "staticView-components";
	var staticViewClassesName = "staticView-classes";
	var deploymentViewName = "deploymentView";
	var validPackageNames = new Sequence();
	validPackageNames.add(staticViewComponentsName);
	validPackageNames.add(staticViewClassesName);
	validPackageNames.add(dynamicViewName);
	validPackageNames.add(deploymentViewName);
	
	// stereotypes
	var gaScenario = "GaScenario";
}

// model structure
context UML!Model {
	
	constraint ExactlyOneModel {
		check : UML!Model.all.size() == 1
		message : "Exactly one model-element is allowed. The model element count is: " + UML!Model.all.size()
	}
	
}

context UML!Package {
	
	constraint HasValidName {
		guard : not self.isTypeOf(UML!Model)
		check : validPackageNames.contains(self.name)
		message {
			return "The valid Package-Names are: " + validPackageNames.concat(", ") + "\n"
			 		+ " The given name is: " + self.name;
		}
	}
	
}


// Dynamic View
context UML!UseCase {

	constraint OwnerIsPackge {
		check : self.getOwner().isDefined() and self.getOwner().isTypeOf(UML!Package)
		message: "Owner of UseCase '" + self.name + "' is not defined or not a package. Owner: " + self.getOwner()
	}
	
	constraint IsInDynamicViewPackage {
		check : self.getOwner().name == dynamicViewName
		message: "Owner of UseCase '" + self.name + "' is not the " + dynamicViewName + "Package. Owner: " + self.getOwner()
	}
	
	constraint HasInteraction {
		check : self.hasInteraction()
		message : "UseCase '" + self.name + "' has no interaction. Behaviours: " + self.getOwnedBehaviors()
	}
	
	constraint GaScenarioStereotypeApplied {
		check : self.isStereotypeApplied(gaScenario)
		message : self.getMessageStereotypeNotApplied(gaScenario)
	}
	
}

context UML!Interaction {
	
/*
Currently not supported since it is impossible to access the enum "AggregationKind" to create a fully correct association
	constraint InteractionHasLifelineWithActor {
		check : self.getLifelines().stream().filter(lf|lf.getRepresents().isTypeOf(UML!Actor)).count() == 1
		message : "Exactly one lifeline was expected to be connected to an actor, found where the following: " + self.getLifelines().stream().filter(lf|lf.getRepresents().isTypeOf(UML!Actor)).collect(Native("java.util.stream.Collectors").toList())
	}
*/

	constraint InteractionHasLifelineEntry {
		check : self.getLifeline("'Entry'").isDefined()
		message : "Lifeline with name 'Entry' was expected, but not found."
	}
	
	
}

context UML!Lifeline {

	constraint NameIsSet {
		check : self.name.isDefined()
		message : "Name of lifeline is not defined: " + self
	}
	
	constraint BehaviorExecutionSpecificationIsSet {
		check  {
			var covered = self.getCoveredBys();
			for (c : UML!BehaviorExecutionSpecification in covered ) {
				return true;
			}
			return false;
		}
		message : "The lifeline '" + self.name + "' has no BehaviorExecutionSpecification"
	}
	
	constraint EntryHasThreeCoveredBy {
		guard : self.name == "'Entry'"
		check : self.getCoveredBys().size() == 3
	}
	
	constraint EntryHasOneBehaviorExecutionSpecification {
		guard : self.name == "'Entry'"
		check : self.getCoveredBys().stream().filter(c|c.isTypeOf(UML!BehaviorExecutionSpecification)).count() == 1
	}
	
}

context UML!Message {
	
	constraint HasSendEvent {
		check : self.getSendEvent().isDefined()
	}

	constraint HasReceiveEvent {
		check : self.getReceiveEvent().isDefined()
	}
	
	constraint HasMessageSort {
		check : self.getMessageSort().isDefined()
	}
	
}

context UML!BehaviorExecutionSpecification {
	
	
	constraint ExactlyOneCovered {
		check : self.getCovereds().size() == 1
	}
	
	constraint CoveredIsLifeline {
		check : self.getCovereds().get(0).isTypeOf(UML!Lifeline)
	}
	
	constraint StartIsSet {
		check : self.getStart().isDefined()
	}

	constraint FinishIsSet {
		check : self.getFinish().isDefined()
	}
	
}

context UML!MessageOccurrenceSpecification {
	
	constraint NumberMustBeUnique {
		guard : self.number.isDefined()
		check : self.isDefined()
		message {
			return "Number attribute must be unique but is not.\n" 
					+ "The number " + self.number + " was found " 
					+ Node.all.select( n | n.number == self.number).size()
					+ " times." ;
			}
	}
	
	constraint MessageIsDefined {
		check : self.getMessage().isDefined()
	}
	
	constraint ExactlyOneCovered {
		check : self.getCovereds().size() == 1
	}
	
	constraint CoveredIsLifeline {
		check : self.getCovereds().get(0).isTypeOf(UML!Lifeline)
	}
}

// Static View

context UML!Component {
	
	constraint HasEdges {
		check : self.isDefined()
	}
	
}

context UML!Interface {
	
	constraint HasEdges {
		check : self.isDefined()
	}
	
}


// Deployment View

context UML!Node {
	
	constraint HasEdges {
		check : self.isDefined()
	}
	
}

context UML!Artifact {
	
	constraint HasEdges {
		check : self.isDefined()
	}
	
}

operation UML!NamedElement getMessageStereotypeNotApplied(stereotypeName : String) : String {
	return "The Stereotype '" + stereotypeName + "' is not applied to UseCase '" + self.name + "'"; 
}


